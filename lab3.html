<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">



  <header>
    <h1>Fractal Geometry <br> Lab Report</h1>
    <p class="author">
      [Colette Chilton] <br />
      [12 February 2025]
  </header>
</body>


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Benoit Mandelbrot: Fractals and the art of roughness</h2>
        <p>
          Video response

		

 <h2>Equilateral Triangle</h2>
        <p>
	There are two cells for the equilateral triangle. The first cell defines the function 
	draw_triangle(length). For each iteration in the given range, which is 3, the turtle 
	moves forward the predetermined length and then turns left 120 degrees, which is the 
	angle for an equilateral triangle. By changing the range and turn, a different shape 
	could be drawn. In the second cell, the function is defined again. Unsure why we are 
	doing this twice. I changed the function to have speed(4) in it so that I could watch 
	the turtle make the shape. This is purely to entertain myself. The parameters are then 
	established: the turtle will begin at the coordinates (300,500), will begin by facing 
	90 degrees which is directly to the right, the color of the drawing will be green, and 
	each side length will be 400 units. The function is then run, and a triangle is drawn.
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

initializeTurtle()
showturtle()

colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']

# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        color(random.choice(colors))
        speed(4)
        forward(length)
        left(120)

# Set up the turtle
jump(300, 500)
face(90)
#color(random.choice(colors))
length = 400
draw_triangle(length)

show()
showturtle()		
	</code></pre>


</section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
        I changed the code to have a random color selected for each side. At first, I had put the random 
	color selector in with the parameters, but that made the whole triangle a single random color from 
	my list, so I put it inside the defined function so that it would pick a new color with each iteration.
        </p>




        <figure>
          <img
            src="equilateral turtle.png"
            alt="equilateral turtle"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Equilateral Turtle
          </figcaption>
        </figure>


      </section>

 <h2>Recursive Sierpinski Triangle Function</h2>
        <p>
	This is also done in two seperate cells. The first cell defines the function for the Sierpinski 
	Triangle as sierpinski_triangle(length, order). If the order is 0, the previously defined function 
	draw_triangle(length) is run. For each increasing order, it draws a new triangle. I expected it to 
	draw the big triangle, and then subsequently draw the smaller triangles inside it. However, when I 
	changed the code to have speed(4), which has come to be my preferred viewing speed, I saw that the 
	turtle is actually drawing each of the tiny triangles individually.
        </p>

      </section>

     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

  def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)



	initializeTurtle()
	showturtle()

	# Set up the turtle
	jump(300, 500)
	face(90)

	# Draw the Sierpinski triangle
	length = 400
	order = 2
	sierpinski_triangle(length, order)

	show()	
		
	</code></pre>


</section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
        Order 1 draws a single triangle large triangle composed of four inner triangles. Order 2 draws three 
	of these triangles, stacked into a triangle. Order 3 draws three of the order 2 triangles, stacked 
	into a triangle. I did not set a speed or tell it to select random colors from a list, however, it 
	is doing this on its own, I assume because I set that for the draw_triangle(length) function and that 
	is being used here as well. Actually, I went back and set speed(0) in the draw_triangle(length) function 
	and it made the Sierpinski Triangle drawing instantaneous, so that assumption was correct. I also 
	tested not dividing the length by 2 in several of the sierpinski_triangle lines to see what was drawing 
	which pieces.
        </p>




        <figure>
          <img
            src="sierpinski turtle.gif"
            alt="sierpinski turtle"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Sierpinski Turtle, Order 2
          </figcaption>
        </figure>




      </section>


       <h2>Cellular Autonama 1</h2>
        <p>
          
	There is a lot python does behind the scenes, such as making the right pixels the right colors.
	In Cellular Automata, python is doing less and I am taking more control. ax.imshow() creates the
	environment to display data as an image. I will input an array of pixel values, turning the screen
	into a grid where each pixel has its own address, and lights are turned on and off for what is being
	shown. C[0. 50] = 1 turns on the light at row 0 and column 50. I imported colormaps and set cmap = 'spring',
	which changed the background to a very hot pink, and the pixel to yellow. I thought changing 
	C[0.50] = 0.5 would change the shade of the pixel but it did not. I added a vmin and vmax and it let me
	enter colors within that range/gradient scale based on the associated number.

	
        </p>
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colormaps

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'Pastel1', vmin = 0, vmax = 1)
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()

C = np.zeros((100,100)).astype(int)
C[0,50] = 1
plot(C)

		
	</code></pre>


</section>


	      
        <p>

	num = 90 is converted to 8 bit binary to be 01011010. Turns out the color map from above is effecting
	the next group of cells, so I had to change vmax to 1. Rule is a 3 dimensional array with dimensions of 1
	in all directions. Like a 1x1x1 cube. The eight values (8 bit binary), converting the binary number digits
	into different points on the cube. Eight values for eight corners. Then CA(X) is defined. The for loops are
	going down each column of the display. N, NW, NE are literally the compass directions. It returns X but
	plots C, which is why the colormap had to be between 0 and 1. One corner of the cube is at (0,0,0) and the
	furthest corner is (1,1,1). N, NW, and NE look at the pixel, the pixel above N, the pixel above left NW and
	the pixel above right NE. Then we use the values of the pixels to select the position in the rule. The 
	positions in rule can only be 0 or 1, hence the color limitations. 
		
      	</p>
	      
	<p>
		
	Anything pink is 0 and anything white is 1. (0,50) is 1 (N) and NW and NE are 0. Pixel (1,50) is pink,
	because it is following the rule for [0,1,0] from cell 142. Repeat this many many times and the 
	Sierpinski Triangle is formed. If NW and NE are 1, then the targeted cell is 0. If either one of the NW
	or NE is 1, then the targeted pixel is 1, creating the diagonals. No two white pixels next to each other.
	[1,1,1] [1,1,0] and [0,1,1] don't do anything because that scenario never appears. These can be changed
	in the rule, and the pixture won't change. So there would be eight numbers (2 cubed) that will give
	the same image.
		
	</p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

num = 72
print(f'{num:08b}')

rule = np.zeros((2,2,2))

rule[0,0,0] = 0
rule[0,0,1] = 1
rule[0,1,0] = 0
rule[0,1,1] = 0
rule[1,0,0] = 1
rule[1,0,1] = 0
rule[1,1,0] = 0
rule[1,1,1] = 0

def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            N  = X[i-1,j]
            NW = X[i-1,j-1]
            NE = X[i-1,j+1]

            X[i,j] = rule[NW,N,NE]

    return X

		
	</code></pre>


</section>


        <figure>
          <img
            src="sierpinski pixels.png"
            alt="sierpinski pixels"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Sierpinski Pixels using "72"
          </figcaption>
        </figure>




      </section>

        
 <h2>Cellular Autonama 2</h2>
        <p>
	notes notes
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<section id="code">
	<pre><code class="language-python">

	This section of code has the targeted pixel as 2 ^ (4*NW + 2*N + NE) mod 2, which is binary conversion,
	from right to left. Changing 90 to odd numbers gives some great stripes.
		
	</code></pre>


</section>

      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
        results results
        </p>




        <figure>
          <img
            src="binary mountains.png"
            alt="binary mountains"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Cool Binary Mountains using "89"
          </figcaption>
        </figure>


      </section>


	    
      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">


      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
        OVERALL CONCLUSION HERE
        </p>
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
